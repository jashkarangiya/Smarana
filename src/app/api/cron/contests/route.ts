import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { fetchAllContests } from "@/lib/contests/fetchers"
import { sendEmail } from "@/lib/email/sendEmail"
import { contestReminderEmail } from "@/lib/email/templates/contestReminder"
import { differenceInHours, format } from "date-fns"

export async function GET(req: Request) {
    const authHeader = req.headers.get("authorization")

    // Simple secret check
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
        return new NextResponse("Unauthorized", { status: 401 })
    }

    try {
        // 1. Fetch latest contests
        const contests = await fetchAllContests()
        const now = new Date()

        // 2. Upsert relevant contests to DB (only those starting soon or recently active)
        // We only really care about future contests for reminders
        const futureContests = contests.filter(
            (c: any) => new Date(c.startsAt).getTime() > now.getTime()
        )

        for (const c of futureContests) {
            // Using upsert to keep DB simplified
            // Map our platform string to DB enum-like string if needed, 
            // but schema.prisma says platform is String, so we represent it as is.
            await prisma.contest.upsert({
                where: {
                    platform_contestId: {
                        platform: c.platform,
                        contestId: c.id, // Using the ID generated by fetcher as contestId
                    },
                },
                update: {
                    startTime: new Date(c.startsAt),
                    url: c.url,
                    phase: c.phase,
                },
                create: {
                    platform: c.platform,
                    contestId: c.id,
                    name: c.name,
                    startTime: new Date(c.startsAt),
                    duration: Math.floor(c.durationSeconds / 60),
                    url: c.url,
                    phase: c.phase,
                },
            })
        }

        // 3. Process Reminders
        // Find contests starting in the next 24 hours
        // We will notify if start time is within [now, now + 24h]
        // AND we haven't already notified the user for this contest
        const next24h = new Date(now.getTime() + 24 * 60 * 60 * 1000)

        const upcomingDbContests = await prisma.contest.findMany({
            where: {
                startTime: {
                    gt: now,
                    lte: next24h,
                },
            },
        })

        if (upcomingDbContests.length === 0) {
            return NextResponse.json({ message: "No upcoming contests in next 24h" })
        }

        // Find users with reminders enabled
        const users = await prisma.user.findMany({
            where: {
                email: { not: null },
                emailContestRemindersEnabled: true,
            },
            select: {
                id: true,
                email: true,
                name: true,
                timezone: true,
                leetcodeUsername: true,
                codeforcesUsername: true,
                atcoderUsername: true,
                // Add more if we support others
            },
        })

        let sentCount = 0

        for (const contest of upcomingDbContests) {
            // Determine if user is interested in this platform
            // Logic: User must have linked username for that platform to receive reminder?
            // OR we send for all platforms?
            // "The user wants to fetch contest data from every website possible."
            // Assuming we only notify if they have a linked account for relevance, 
            // BUT for platforms like "KickStart" or "TopCoder" we don't have username fields in DB.
            // Let's stick to the platforms we have explicit fields for, plus maybe a generic rule?
            // Implementation Plan said: "Filter users based on linked platforms".

            const interestedUsers = users.filter((u) => {
                if (contest.platform === "leetcode") return !!u.leetcodeUsername
                if (contest.platform === "codeforces") return !!u.codeforcesUsername
                if (contest.platform === "atcoder") return !!u.atcoderUsername
                // For other platforms, we might skip to avoid spam, or include them if super generic.
                // Let's include them only if we have a way to know, otherwise default to NO to avoid spam.
                // Or maybe we can enable a "notify all contests" setting later.
                // For now, only mapped platforms.
                return false
            })

            for (const user of interestedUsers) {
                // Check if already reminded
                const existingReminder = await prisma.contestReminder.findUnique({
                    where: {
                        userId_contestId: {
                            userId: user.id,
                            contestId: contest.id,
                        },
                    },
                })

                if (existingReminder?.notified) continue

                // Send Email
                const appUrl = process.env.APP_URL || process.env.NEXTAUTH_URL || "http://localhost:3000"
                const logoUrl = new URL("/logo.png", appUrl).toString()

                // Format start time
                // Ideally use user's timezone if valid, else UTC
                let startTimeLocal = format(contest.startTime, "PP p") // localized default

                const hoursUntil = differenceInHours(contest.startTime, now)
                const startInText = hoursUntil === 0 ? "less than an hour" : `in ${hoursUntil} hours`

                try {
                    const { subject, html, text } = contestReminderEmail({
                        appUrl,
                        logoUrl,
                        username: user.name,
                        platform: contest.platform,
                        contestName: contest.name,
                        startTimeLocal,
                        startInText,
                        contestUrl: contest.url,
                    })

                    await sendEmail({
                        to: user.email!,
                        subject,
                        html,
                        text,
                    })

                    // Mark as notified
                    await prisma.contestReminder.upsert({
                        where: {
                            userId_contestId: {
                                userId: user.id,
                                contestId: contest.id,
                            },
                        },
                        update: {
                            notified: true,
                            notifyAt: now,
                        },
                        create: {
                            userId: user.id,
                            contestId: contest.id,
                            notified: true,
                            notifyAt: now,
                        },
                    })

                    sentCount++
                } catch (e) {
                    console.error(`Failed to send contest reminder to ${user.email}`, e)
                }
            }
        }

        return NextResponse.json({
            success: true,
            contestsFetched: contests.length,
            remindersSent: sentCount,
        })
    } catch (error) {
        console.error("Cron contest sync failed:", error)
        return new NextResponse("Internal Server Error", { status: 500 })
    }
}
